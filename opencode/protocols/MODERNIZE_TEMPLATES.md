# Modernize Artifact Templates

Use these templates for `/run-modernize` outputs to keep structure consistent.
See `opencode/protocols/MODERNIZE_EXAMPLE.md` for a concrete example.

All artifacts follow a **Source-to-Target migration model**:
- **Source Project (A):** The legacy system being analyzed (read-only).
- **Target Project (B):** The new project where the modernized system will be built.

## Format Requirements

Every artifact MUST be human-readable and include:
1. **Executive Summary** (1-2 sentences at the top)
2. **Table of Contents** (for long artifacts, typically more than 5 sections)
3. **Section Structure** (consistent headings; numbering optional)
4. **Narrative Context** (add prose where needed, not just headers)
5. **Source/Target References** (every artifact must reference both project paths)

If a section is not applicable, write `N/A` with a short reason.

## Depth Profiles (lite|standard|deep)

When `--depth` is provided, apply these conventions:

- **lite**: Focus on decisions and next actions. Prefer short bullets and omit long background. Limit optional sections where allowed.
- **standard**: Default balance of context, decisions, and risks. Keep sections concise and concrete.
- **deep**: Include decision rationale and alternatives. Keep evidence compact; move details to short appendices when needed.

> **Note:** Paths below show the default `.pipeline-output/` convention. When `--output-dir` is used, substitute accordingly.

## Quality Bar (MANDATORY)

These rules define the minimum acceptable quality for every artifact. Artifacts that violate these MUST be rejected during review.

### What good looks like

- Key sections include brief context so readers can interpret tables/lists quickly.
- Tables have introductory text (e.g. "The following table maps each legacy component to a refactor-vs-rewrite recommendation based on coupling and risk.").
- Risk entries cite specific code paths, dependencies, or architectural patterns — not generic categories.
- Recommendations include concrete actions (e.g. "Replace `FormsAuthentication.SetAuthCookie()` with `HttpContext.SignInAsync()` using a custom `ClaimsPrincipal`").
- File and class references use the format `path/to/File.cs:ClassName` when referencing specific code.

### Anti-patterns (EXPLICITLY PROHIBITED)

1. **Bold-header-one-liner** — For critical sections, avoid `**Header**\nOne sentence.`. This is usually a note, not a decision-ready document.
2. **Generic risk statements** — "High coupling makes refactors risky" without specifying WHICH coupling, WHERE, and HOW it manifests.
3. **Pipeline self-certification** — Any content whose purpose is proving the pipeline "did its job" (e.g. DoD checklists, evidence indexes, proof bundles, trace matrices). These are internal pipeline artifacts and MUST NOT be in user-facing documents.
4. **Invented governance processes** — Creating elaborate gate/review/approval frameworks that the user didn't ask for and won't use. Keep governance sections practical and lightweight unless the user explicitly requests formal governance.
5. **Duplicate files** — Creating separate files for deferred scope, handoff prompts, or inventory dumps. All content belongs in the 5 defined artifacts.

### Minimum depth per section

- No fixed word minimums.
- Keep sections concise but specific, with concrete evidence and decisions.
- If a section genuinely has nothing to say, write `N/A — [reason]` rather than padding with generic text.

### Deferred scope handling

If the user provides scope exclusions (features to remove, controllers to defer, modules to skip):
- Do NOT create a separate `deferred-backlog-register.md` or similar file.
- Include a "Deferred Scope" section in `modernize-migration-roadmap.md` listing excluded items with phase tags and rationale.
- Reference the deferred items in other documents where relevant (e.g. the source assessment should note which modules are excluded, the strategy should explain why they're excluded).

---

## .pipeline-output/modernize/modernize-index.md

> Navigation page produced by Stage 3 (Synthesis). NOT an artifact task — generated by the orchestrator.

```markdown
# Modernization Plan — <project name>

Source: <source project path>
Target: <target project path>

## Documents

1. [Source Assessment](modernize-source-assessment.md) — Current state analysis of project A
2. [Target Design](modernize-target-design.md) — Architecture and structure of project B
3. [Migration Strategy](modernize-migration-strategy.md) — How to build B while A runs
4. [Migration Roadmap](modernize-migration-roadmap.md) — Timeline, phases, and milestones
5. [Migration Risks](modernize-migration-risks.md) — Risk register and governance

## Key Decisions
<Bullet list>

## Open Questions
<Bullet list>

## Next Steps
<Recommendations for /run-pipeline in the target project>
```

---

## .pipeline-output/modernize/modernize-source-assessment.md

```markdown
# Source Assessment — <project name>

> **Source:** <source project path>
> **Target:** <target project path>

<Executive summary: 1-2 sentences describing the current state of project A, primary stack, and migration readiness.>

## Table of Contents

1. [Source Project Overview](#1-source-project-overview)
2. [Architecture Snapshot](#2-architecture-snapshot)
3. [Key Dependencies](#3-key-dependencies)
4. [Operational Pain Points](#4-operational-pain-points)
5. [Performance Bottlenecks](#5-performance-bottlenecks)
6. [Security & Compliance Gaps](#6-security--compliance-gaps)
7. [Technical Debt Inventory](#7-technical-debt-inventory)
8. [Migration Readiness Score](#8-migration-readiness-score)
9. [Risks](#9-risks)
10. [Open Questions](#10-open-questions)

## 1. Source Project Overview

<Project path, solution structure, language/framework versions, deployment model, team context. Include specific file references (e.g. "The solution `NetService.sln` contains two projects...").>

## 2. Architecture Snapshot

<High-level architecture description. Layers, services, data flow, entry points. Describe the request pipeline, middleware stack, authentication flow, and how controllers are organized. Include a logical architecture diagram in text/ASCII if helpful.>

## 3. Key Dependencies

<External services, libraries, infrastructure dependencies with version numbers. Organize by category (runtime, data, auth, DI, integration). Reference specific config files (packages.config, Web.config, etc.).>

## 4. Operational Pain Points

<What causes friction in development, deployment, or operations. Be specific — cite concrete examples from the codebase, not generic observations.>

## 5. Performance Bottlenecks

<Known performance issues with evidence. Reference specific query patterns, EF context usage, request pipeline inefficiencies.>

## 6. Security & Compliance Gaps

<Known vulnerabilities, weak practices, outdated dependencies. Include file paths where issues are found (e.g. "MD5 hashing in `Utils/HashHelper.cs`").>

## 7. Technical Debt Inventory

<Categorized list of tech debt items with severity (high/medium/low). Each item should reference specific code locations.>

## 8. Migration Readiness Score

<Per-component readiness assessment. Which parts are easiest to migrate first and why. Use a table:>

| Component | Readiness | Rationale |
|-----------|-----------|-----------|
| ... | High/Medium/Low | ... |

## 9. Risks

<Risks specific to understanding or analyzing the source system. Each risk should be specific, not generic.>

## 10. Open Questions

<What needs clarification before proceeding. Reference specific areas of the codebase where analysis was inconclusive.>
```

---

## .pipeline-output/modernize/modernize-target-design.md

```markdown
# Target Design — <project name>

> **Source:** <source project path>
> **Target:** <target project path>

<Executive summary: 1-2 sentences describing the target project B, key architectural choices, and relationship to project A.>

## Table of Contents

1. [Target Project Overview](#1-target-project-overview)
2. [Target Architecture](#2-target-architecture)
3. [Directory Layout](#3-directory-layout)
4. [Tech Stack Choices](#4-tech-stack-choices)
5. [Non-Functional Goals](#5-non-functional-goals)
6. [Modularity Strategy](#6-modularity-strategy)
7. [Data Strategy](#7-data-strategy)
8. [Observability Strategy](#8-observability-strategy)
9. [API Contract with Source (During Migration)](#9-api-contract-with-source-during-migration)
10. [Key Tradeoffs](#10-key-tradeoffs)
11. [Open Questions](#11-open-questions)

## 1. Target Project Overview

<Project path, name, relationship to source project A. What is being built and what is explicitly NOT being built in this phase.>

## 2. Target Architecture

<High-level architecture of project B. Layers, services, data flow. Include a logical architecture diagram in text/ASCII if helpful. Explain how the architecture addresses the pain points identified in the source assessment.>

## 3. Directory Layout

<Proposed directory structure for the target project. Use a tree diagram. Explain the rationale for the layout choices.>

## 4. Tech Stack Choices

<Language, framework, database, infrastructure choices with version targets and rationale for each choice. Use a table:>

| Layer | Technology | Version | Rationale |
|-------|-----------|---------|-----------|
| ... | ... | ... | ... |

## 5. Non-Functional Goals

<Performance targets, scalability requirements, reliability SLAs. Be specific and measurable where possible.>

## 6. Modularity Strategy

<How the system is decomposed. Module boundaries, dependency rules, interface contracts.>

## 7. Data Strategy

<Database design direction, EF Core context strategy, data migration approach. If consolidating contexts, explain the entity groupings and why.>

## 8. Observability Strategy

<Logging, monitoring, alerting, tracing approach for project B. What gets instrumented and why.>

## 9. API Contract with Source (During Migration)

<How A and B coexist during the parallel-run period. Shared interfaces, routing strategy, data consistency approach. If there is no parallel run (full cutover), explain why.>

## 10. Key Tradeoffs

<Major tradeoffs made in the target design and their rationale. Each tradeoff should explain what was gained and what was given up.>

## 11. Open Questions

<Decisions that need stakeholder input before target design is finalized.>
```

---

## .pipeline-output/modernize/modernize-migration-strategy.md

```markdown
# Migration Strategy — <project name>

> **Source:** <source project path>
> **Target:** <target project path>

<Executive summary: 1-2 sentences on the chosen migration approach and why.>

## Table of Contents

1. [Migration Approach](#1-migration-approach)
2. [Strangler Fig Boundaries](#2-strangler-fig-boundaries)
3. [Refactor vs. Rewrite Decisions](#3-refactor-vs-rewrite-decisions)
4. [Parallel-Run Strategy](#4-parallel-run-strategy)
5. [Data Migration Plan](#5-data-migration-plan)
6. [Backward Compatibility](#6-backward-compatibility)
7. [Cutover Criteria](#7-cutover-criteria)
8. [Rollback Plan](#8-rollback-plan)
9. [Dependencies Sequencing](#9-dependencies-sequencing)
10. [Risk Mitigations](#10-risk-mitigations)
11. [Open Questions](#11-open-questions)

## 1. Migration Approach

<Overall strategy choice and rationale. Why this approach was chosen over alternatives.>

## 2. Strangler Fig Boundaries

<Which components/routes/services get migrated first and why. How traffic is split between A and B during migration. Include a table mapping migration slices to controller groups:>

| Slice | Controllers/Routes | Prerequisite | Rationale |
|-------|-------------------|--------------|-----------|
| ... | ... | ... | ... |

## 3. Refactor vs. Rewrite Decisions

<Decision table for each major component. Include the decision criteria used.>

The following table maps each legacy component area to a refactor-vs-rewrite recommendation:

| Area | Decision | Criteria Applied | Notes |
|------|----------|-----------------|-------|
| ... | Refactor/Rewrite/Defer | ... | ... |

## 4. Parallel-Run Strategy

<How A and B run simultaneously. Traffic routing mechanism, feature flags, shadow mode. If no parallel run, explain why.>

## 5. Data Migration Plan

<How data moves from A to B. Schema changes, dual-write strategy, ETL, or shared-database approach.>

## 6. Backward Compatibility

<What compatibility guarantees exist during migration. Route stability, API versioning, shared schemas.>

## 7. Cutover Criteria

<Measurable criteria for when a component can be cut over from A to B. Include specific metrics and thresholds.>

## 8. Rollback Plan

<How to roll back to A if B fails. Per-slice and full-system rollback procedures. Include rollback triggers (what conditions trigger a rollback).>

## 9. Dependencies Sequencing

<Order of component migration based on coupling and risk. Explain dependency chains.>

## 10. Risk Mitigations

<Strategy-level risk mitigations. Each mitigation should reference a specific risk from the risk register.>

## 11. Open Questions

<Strategy decisions requiring more information.>
```

---

## .pipeline-output/modernize/modernize-migration-roadmap.md

```markdown
# Migration Roadmap — <project name>

> **Source:** <source project path>
> **Target:** <target project path>

<Executive summary: 1-2 sentences on timeline, phase count, estimated duration, and key milestones.>

## Table of Contents

1. [Phase Overview](#1-phase-overview)
2. [Phase 0: Target Scaffold](#2-phase-0-target-scaffold)
3. [Phase 1–N: Component Migration](#3-phase-1n-component-migration)
4. [Cutover Phase](#4-cutover-phase)
5. [Parallel-Run Period](#5-parallel-run-period)
6. [Decommission Plan for Source](#6-decommission-plan-for-source)
7. [Deferred Scope](#7-deferred-scope)
8. [Milestones](#8-milestones)
9. [Dependencies](#9-dependencies)
10. [Exit Criteria](#10-exit-criteria)
11. [Open Questions](#11-open-questions)

## 1. Phase Overview

<High-level timeline with phases and estimated durations. A summary table is helpful:>

| Phase | Focus | Duration | Key Deliverable |
|-------|-------|----------|-----------------|
| ... | ... | ... | ... |

## 2. Phase 0: Target Scaffold

<Initial setup of project B — repo creation, CI/CD, base infrastructure, container baseline. Concrete deliverables and exit criteria.>

## 3. Phase 1–N: Component Migration

<Per-phase breakdown. Each phase should include:>
- Which components move in this phase
- Specific deliverables
- Acceptance criteria / parity checks
- Dependencies on prior phases
- Estimated effort

## 4. Cutover Phase

<Final migration phase — traffic switch, DNS, database cutover. Step-by-step cutover procedure.>

## 5. Parallel-Run Period

<Duration and exit criteria for running A and B simultaneously. Monitoring and comparison strategy.>

## 6. Decommission Plan for Source

<How project A is shut down after full cutover. Data archival, DNS teardown, team transition.>

## 7. Deferred Scope

<Items explicitly excluded from the current migration scope. This section replaces any separate deferred-backlog file.>

If the user specified scope exclusions, list them here with rationale and future phase assignment:

| Item | Type | Rationale for Deferral | Target Phase |
|------|------|----------------------|--------------|
| ... | ... | ... | Phase N |

<Include an explicit exclusion statement: these items are NOT part of the current migration scope and must not be pulled in without formal approval.>

## 8. Milestones

<Key milestone dates/triggers with measurable criteria.>

## 9. Dependencies

<Cross-team or external dependencies that affect the timeline.>

## 10. Exit Criteria

<What defines "done" for the entire modernization. Measurable and verifiable criteria.>

## 11. Open Questions

<Timeline uncertainties.>
```

---

## .pipeline-output/modernize/modernize-migration-risks.md

```markdown
# Migration Risks & Governance — <project name>

> **Source:** <source project path>
> **Target:** <target project path>

<Executive summary: 1-2 sentences on top risks and the governance model used to manage them.>

## Table of Contents

1. [Risk Register](#1-risk-register)
2. [Dual-System Risks](#2-dual-system-risks)
3. [Data Consistency Risks](#3-data-consistency-risks)
4. [Cutover Risks](#4-cutover-risks)
5. [Rollback Scenarios](#5-rollback-scenarios)
6. [Operational Risks](#6-operational-risks)
7. [Security Risks](#7-security-risks)
8. [Mitigations](#8-mitigations)
9. [Governance Model](#9-governance-model)
10. [Open Questions](#10-open-questions)

## 1. Risk Register

The following table summarizes all identified migration risks. Each risk has a unique ID for cross-referencing in other documents.

| ID | Risk | Likelihood | Impact | Priority | Mitigation | Owner |
|----|------|-----------|--------|----------|------------|-------|
| R1 | ... | High/Med/Low | Critical/High/Med/Low | ... | ... | ... |

## 2. Dual-System Risks

<Risks from running A and B simultaneously — drift, inconsistency, operational overhead. Be specific about which components create dual-system risk.>

## 3. Data Consistency Risks

<Risks from data existing in both systems — conflicts, stale reads, replication lag. Reference specific tables/entities.>

## 4. Cutover Risks

<Risks during the final switch — downtime, data loss, rollback failure. Include specific failure scenarios.>

## 5. Rollback Scenarios

<Specific scenarios where rollback is needed and how each is handled. Include trigger conditions, rollback procedure, and expected recovery time.>

## 6. Operational Risks

<Team capacity, knowledge gaps, tooling gaps, infrastructure risks. Be concrete.>

## 7. Security Risks

<New attack surfaces, credential management across two systems, compliance gaps. Reference specific code paths and configuration issues.>

## 8. Mitigations

<Consolidated mitigation plan for the highest-impact risks. Each mitigation should reference its risk ID and include:>
- Specific action to take
- Who is responsible
- When it must be completed
- How to verify it worked

## 9. Governance Model

<Decision-making process, escalation paths, review cadence, stakeholder communication. Keep this practical and lightweight — do not invent elaborate multi-gate approval frameworks unless the user explicitly requests formal governance.>

## 10. Open Questions

<Risk-related unknowns that need investigation or stakeholder input.>
```
